1. Какой самый эффективный способ конкатенации строк?

С помощью strings.Builder (с заранее выделенным капасити, если оно известно)

2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы дают возможность задать ограничения на тип в виде списка методов, которые должны быть реализованы.
В параметре функции или поле структуры, имеющих интерфейсный тип, можно использовать объект любого типа,
пока он удовлетворяет интерфейсу.
Интерфейсы помогают уменьшить дублирование.
Они облегчают использование в юнит тестах заглушек вместо реальных объектов.
Используются для отвязки определённых частей кода от использования конкретных типов (например,
HTTP-уровень и уровень взаимодействия с базой данных).

3. Чем отличаются RWMutex от Mutex?

RWMutex это вид мьютекса, который позволяет одновременно выполняться либо произвольному количеству операций чтения,
либо одной операции записи. При этом нельзя выполнять одновременно запись и чтение.
RWMutex работает чуть медленнее Mutex.

4. Чем отличаются буферизированные и не буферизированные каналы?

Операции чтения и записи в небуферизированный канал ожидают, когда другая горутина соответственно запишет
или прочитает данные.
Буферизированный канал накапливает данные. Когда канал пуст, горутина встаёт в режим ожидания при чтении.
Когда канал полон, горутина встаёт в режим ожидания при записи.

5. Какой размер у структуры struct{}{}?

0 байт

6. Есть ли в Go перегрузка методов или операторов?

В Go нет перегрузки методов или операторов.

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281

Структура map не гарантирует порядок итераций по ней.

8. В чем разница make и new?

new инициализирует нулевое значение для данного типа и возвращает указатель на этот тип.
make используется для создания и инициализации слайсов, мап и каналов,
возвращает ненулевой экземпляр указанного типа.

9. Сколько существует способов задать переменную типа slice или map?

- var slice []T
- slice := []T{}
- slice := []T{a,b,...}
- slice := make([]T, len, cap)
- slice := make([]T, len)
- arr := [3]T{a,b,c}
  slice := arr[:]
- slice := []T{a,b,...}
  slice2 := slice[1:2]

- var m map[T]T
- m := make(map[T]T)
- m := make(map[T]T, cap)
- m = map[T]T{}
- m := map[T]T{a:b,...}

